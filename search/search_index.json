{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FECo3","text":"<p>Python bindings for a <code>.fec</code> file parser in rust.</p> <p>Install with <code>pip install feco3</code></p> <ul> <li>API docs</li> <li>Repository</li> </ul>"},{"location":"#example","title":"Example","text":"example.py<pre><code>import feco3\nimport pyarrow as pa\n# ruff: noqa: E501\n# You can supply a URL or a path to a file.\nsrc = \"https://docquery.fec.gov/dcdev/posted/1002596.fec\"\n# src = \"path/to/file.fec\"\n# src = pathlib.Path(\"path/to/file.fec\")\n# The straightforward way is to just parse to a directory of files,\n# one file for each itemization type, eg \"csvs/SA11AI.csv\", etc\nfeco3.FecFile(src).to_csvs(\"csvs/\")\nfeco3.FecFile(src).to_parquets(\"parquets/\")\n# Or, you can look at the file at a lower level.\n# This doesn't actually read or parse any data yet\nfec = feco3.FecFile(src)\nprint(fec)\n# FecFile(src='https://docquery.fec.gov/dcdev/posted/1002596.fec')\n# Only when we access something do we actually start parsing.\n# Still, we only parse as far as we need to, so this is quite fast.\n# This is useful, for example, if you only need the header or cover,\n# or if you only want to look at the itemizations in certain forms.\nprint(fec.header)\nprint(fec.cover)\n# Header(fec_version='8.1', software_name='NetFile', software_version='199199', report_id=None, report_number='0')\n# Cover(form_type='F3N', filer_committee_id='C00479188')\n# Iterate through the itemizations in the file in batches of pyarrow RecordBatches.\n# By iterating, this keeps us from having to load the entire file into memory.\n# By using pyarrow, we can avoid copying the underlying data from Rust to Python.\n# It integrates well with the rest of the Python data ecosystem, for example\n# it's easy to convert to a pandas DataFrames.\nbatcher = feco3.PyarrowBatcher(fec, max_batch_size=1024 * 1024)\nfor batch in batcher:\n# The record code for this kind of itemizations, eg. 'SA11AI'\nassert isinstance(batch.code, str)\n# A pyarrow RecordBatch of the itemizations\nassert isinstance(batch.records, pa.RecordBatch)\ndf = batch.records.to_pandas()\nprint(batch.code)\nprint(df.head(3))\n# SA15\n#   filer_committee_id_number transaction_id back_reference_tran_id_number back_reference_sched_name  ... conduit_zip_code memo_code memo_text_description reference_code\n# 0                 C00479188        INCA994                                                          ...\n# 1                 C00479188        INCA992                                                          ...\n# 2                 C00479188        INCA993                                                          ...\n# [3 rows x 44 columns]\n# TEXT\n#   filer_committee_id_number transaction_id_number back_reference_tran_id_number back_reference_sched_form_name            text\n# 0                 C00479188              TPAYC760                       PAYC760                          SC/10  PERSONAL FUNDS\n# SC/10\n#   filer_committee_id_number transaction_id_number receipt_line_number entity_type  ... lender_candidate_state lender_candidate_district memo_code memo_text_description\n# 0                 C00479188               PAYC760                 13B         CAN  ...\n# [1 rows x 37 columns]                       ...\n</code></pre>"},{"location":"API/","title":"API","text":""},{"location":"API/#feco3.__version__","title":"__version__  <code>module-attribute</code>","text":"<pre><code>__version__ = _version.get_version()\n</code></pre> <p>Version string for this package.</p>"},{"location":"API/#feco3.FecFile","title":"FecFile","text":"<pre><code>FecFile(src: str | os.PathLike) -&gt; None\n</code></pre> <p>An FEC file.</p> <p>This doesn't do any reading or parsing until you access one of the members.</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>str | os.PathLike</code> <p>A path or a URL to an FEC file. If a string that starts with \"http://\" or \"https://\", it will be treated as a URL. Otherwise, it will be treated as a path.</p> required"},{"location":"API/#feco3.FecFile.cover","title":"cover  <code>cached</code> <code>property</code>","text":"<pre><code>cover: Cover\n</code></pre> <p>The Cover of the FEC file.</p> <p>The first time this is accessed, the FEC file will be read and parsed as far as needed. Subsequent accesses will return the same object.</p>"},{"location":"API/#feco3.FecFile.header","title":"header  <code>cached</code> <code>property</code>","text":"<pre><code>header: Header\n</code></pre> <p>The Header of the FEC file.</p> <p>The first time this is accessed, the FEC file will be read and parsed as far as needed. Subsequent accesses will return the same object.</p>"},{"location":"API/#feco3.FecFile.to_csvs","title":"to_csvs","text":"<pre><code>to_csvs(out_dir: str | os.PathLike) -&gt; None\n</code></pre> <p>Write all itemizations in this FEC file to CSV files.</p> <p>There will be one CSV file for each record type, eg. <code>sa11.csv</code>.</p>"},{"location":"API/#feco3.FecFile.to_parquets","title":"to_parquets","text":"<pre><code>to_parquets(out_dir: str | os.PathLike) -&gt; None\n</code></pre> <p>Write all itemizations in this FEC file to parquet files.</p> <p>There will be one parquet file for each record type, eg. <code>sa11.parquet</code>.</p>"},{"location":"API/#feco3.Header","title":"Header","text":"<p>         Bases: <code>NamedTuple</code></p> <p>The header of a FecFile.</p> <p>Attributes:</p> Name Type Description <code>fec_version</code> <code>str</code> <p>The version of the FEC file format.</p> <code>software_name</code> <code>str</code> <p>The name of the software that generated the file.</p> <code>software_version</code> <code>str | None</code> <p>The version of the software that generated the file. This isn't present in some older FEC files.</p> <code>report_id</code> <code>str | None</code> <p>If this .fec file is an amendment to a previous filing, the filing number of the original.</p> <code>report_number</code> <code>str | None</code> <p>If this .fec file is an amendment to a previous filing, which number amendement this is (1, 2, 3 etc)</p>"},{"location":"API/#feco3.Cover","title":"Cover","text":"<p>         Bases: <code>NamedTuple</code></p> <p>The Cover Line of an FecFile.</p> <p>Attributes:</p> Name Type Description <code>form_type</code> <code>str</code> <p>The form type of the filing, eg. \"F3\"</p> <code>filer_committee_id</code> <code>str</code> <p>The FEC-assigned ID of the committee that filed the report, eg \"C00618371\"</p>"},{"location":"API/#feco3.ItemizationBatch","title":"ItemizationBatch","text":"<p>         Bases: <code>NamedTuple</code></p> <p>A batch of itemizations.</p> <p>Attributes:</p> Name Type Description <code>code</code> <code>str</code> <p>The code of the itemization type, eg. \"SA11AI\"</p> <code>records</code> <code>pa.RecordBatch</code> <p>A pyarrow.RecordBatch of itemizations.</p>"},{"location":"API/#feco3.PyarrowBatcher","title":"PyarrowBatcher","text":"<pre><code>PyarrowBatcher(\nfec_file: FecFile, max_batch_size: int | None = None\n) -&gt; None\n</code></pre> <p>Iterates an FecFile and yields ItemizationBatchs of itemizations.</p> <p>Parameters:</p> Name Type Description Default <code>fec_file</code> <code>FecFile</code> <p>The FecFile to iterate.</p> required <code>max_batch_size</code> <code>int | None</code> <p>The max rows per pyarrow.RecordBatch. Defaults to 1024 * 1024, which is what rust parquet uses.</p> <code>None</code>"},{"location":"API/#feco3.PyarrowBatcher.__next__","title":"__next__","text":"<pre><code>__next__() -&gt; ItemizationBatch\n</code></pre> <p>Get the next batch of itemizations from the FEC file.</p>"}]}